# 정렬 알고리즘
    데이터를 정렬해야 하는 이유는 탐색을 위해서...

    데이터가 정렬되어 있지 않다면, 
        => 순차 탐색 밖에 사용할 수 없다
    데이터가 정렬되어 있다면, 
        => 이진 탐색이라는 강력한 알고리즘을 사용할 수 있다.


<hr/>

## <O($n²$)>
### - **버블 정렬**
- 연속된 2개의 인덱스를 비교하여 그중 큰 값을 뒤로 넘겨 정렬하는 방법.
        - 위와 같이 한 바퀴를 돌게 되면, 맨 뒤에는 제일 큰 값이 정렬되게 됨.
        - 그럼 다시 앞에서부터 로직을 반복
### - **선택 정렬**
- 이름에 걸맞게 현재 위치에 들어갈 값을 찾아 배열하는 방법.
- 맨 앞의 인덱스부터 이를 포함한 이후의 값들중 가장 작은 것을 찾아 맨 앞으로 가져온다.
### - **삽입 정렬**
- 2번째 인덱스부터 시작하여 그 앞의 값들과의 비교를 진행 한 뒤, 적절한 위치에 삽입하는 정렬.
- 최악의 경우, n²의 시간복잡도를 가지나, 이미 정렬되어 있는 경우, n의 복잡도를 가진다.

<hr/>

## <O($n\log n$)>
### - **이진 정렬**
- **삽입 정렬을 개선한 알고리즘**
- 기본적으로 ??
### - **합병 정렬**
- **분할 정복(Divide and conquer) 방식**으로 설계된 알고리즘
        - 큰 문제를 반으로 쪼개서 해결해 나가는 방식
        - 분할은 배열의 크기가 1이하가 될 때까지 반복한다
- 분할은 $ 2N/2+4N/4+8N/8+... $의 과정을 거치며, 결국 $logN$만큼을 반복하게 된다.
- 각 분할별로 정렬을 다시 진행함으로 N번만큼을 수행한다.
- 결국 시간 복잡도는 $NlogN$을 가짐
### - **힙 정렬**
-
### - **퀵 정렬**
- 이것 또한 **분할 정복(Divide and conquer)방식**을 이용하는 알고리즘
        1. 랜덤으로 하나의 위치(pivot)를 잡고
        2. '왼쪽'은 pivot보다 큰값 => 조건 1
        3. 오른쪽은 pivot보다 작은값이 => 조건 2
        4. 나올때까지 좌우에서부터 인덱스를 좁혀들어가며
        5. 양쪽이 다 조건을 만족하면 좌/우 값들의 위치를 교환한다.
        6. 좌/우 인덱스가 좌>우 일때까지 반복한다.
        7. 이때 '왼쪽'의 인덱스를 pivot의 인덱스로 변경한다.
        8. 이후 pivot을 기준으로 좌/우를 퀵 정렬을 반복한다.
- 각 정렬의 비교는 N만큼, 분할은 $logN$ 진행하므로 총 비교 횟수는 $NlogN$이다.
- 배열이 이미 정렬되어있는 경우가 Worst case 이며, 이때의 시간 복잡도는 $N^2$이다
### - **트리 정렬**
-

<hr/>

## <하이브리드 정렬>
### - **팀 정렬**
-
### - **블록 병합 정렬**
-
### - **인트로 정렬**
-

<hr/>

## <그 밖에..>
### - **기수 정렬**
-
### - **계수 정렬**
-
### - **셸 정렬**
-
### - **대기 정렬**
-
### - **중력 정렬**
-

<hr/>

## <비효율적인 정렬>
### - **꼭두각시 정렬**
-
### - **보고 정렬**
-
### - **보고보고 정렬**
-